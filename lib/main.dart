import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:f35_flight_compensation/l10n2/app_localizations.dart';

import 'package:provider/provider.dart';

// Conditional import for Firebase
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // Generated by FlutterFire CLI

// CRITICAL IMPORTS - DO NOT REMOVE
// These imports MUST be loaded before any other code to ensure our patches are applied
// Even though they appear unused, they contain extensions and monkey patches that
// override default behavior of Flutter's AppLocalizations to prevent null check errors
// The order of imports is important - do not change it!
import 'core/app_localizations_patch.dart'; // Monkey patches AppLocalizations.of
import 'core/emergency_null_safety.dart'; // Provides fallback safety mechanisms

// Regular service imports
import 'package:f35_flight_compensation/core/services/service_initializer.dart';
import 'package:f35_flight_compensation/core/accessibility/accessibility_service.dart';
import 'package:f35_flight_compensation/services/auth_service_firebase.dart';
import 'package:f35_flight_compensation/services/document_storage_service.dart';
import 'package:f35_flight_compensation/services/localization_service.dart';
import 'package:f35_flight_compensation/services/push_notification_service.dart';
import 'package:f35_flight_compensation/services/in_app_messaging_service.dart';
import 'utils/translation_initializer.dart';

import 'package:f35_flight_compensation/screens/main_navigation.dart';
import 'screens/profile_edit_screen.dart';
import 'package:f35_flight_compensation/screens/auth_screen.dart'; // Import for AuthScreen
// import 'screens/email_auth_screen.dart'; // Deprecated: unified via AuthScreen
import 'screens/claim_submission_screen.dart';
import 'screens/flight_compensation_checker_screen.dart';
import 'screens/accessibility_settings_screen.dart';
import 'screens/language_selection_screen.dart';
import 'screens/push_notification_test_screen.dart';
import 'screens/donation_screen.dart';

import 'screens/community_impact_screen.dart';
import 'core/privacy/consent_banner.dart';
import 'screens/privacy_policy_screen.dart';
import 'screens/terms_of_service_screen.dart';
import 'screens/cookie_policy_screen.dart';
import 'screens/legal_notice_screen.dart';
import 'screens/accessibility_statement_screen.dart';
import 'screens/claim_attachment_screen.dart';

// REMOVED: The old emergency extension has been replaced by the more comprehensive implementation in app_localizations_patch.dart

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // EMERGENCY: Initialize all null safety patches first thing
  // This must happen before any other code runs to prevent null check errors
  try {
    debugPrint('üì¶ EMERGENCY: Initializing null safety patches...');
    EmergencyNullSafety.initializeAll();
  } catch (e) {
    debugPrint('‚ùå EMERGENCY: Failed to initialize patches: $e');
  }
  
  // EMERGENCY: Global error handler to prevent null check crashes
  FlutterError.onError = (FlutterErrorDetails details) {
    debugPrint('üî¥ EMERGENCY: Caught Flutter error: ${details.exception}');
    debugPrint('üî¥ EMERGENCY: Stack trace: ${details.stack}');
    // Don't crash the app, just log the error
  };
  
  // EMERGENCY: Catch all unhandled errors
  runZonedGuarded(() async {
    await _initializeApp();
  }, (error, stackTrace) {
    debugPrint('üî¥ EMERGENCY: Caught unhandled error: $error');
    debugPrint('üî¥ EMERGENCY: Stack trace: $stackTrace');
    // Don't crash the app, just log the error
  });
}

Future<void> _initializeApp() async {
  // Initialize Firebase using the generated options file.
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  debugPrint('‚úÖ Firebase initialized successfully');

  // Initialize services asynchronously
  await ServiceInitializer.initAsync();
  
  // Initialize push notifications after Firebase and services are ready
  try {
    await PushNotificationService.initialize();
    await InAppMessagingService.initialize();
    debugPrint('‚úÖ Push notifications initialized successfully');
  } catch (e) {
    debugPrint('‚ùå Failed to initialize push notifications: $e');
  }
  
  // Ensure all translations are properly loaded at startup
  TranslationInitializer.ensureAllTranslations();
  
  runApp(const F35FlightCompensationApp());
}

class F35FlightCompensationApp extends StatelessWidget {
  const F35FlightCompensationApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Get service instances
    final accessibilityService = ServiceInitializer.get<AccessibilityService>();
    final localizationService = ServiceInitializer.get<LocalizationService>();
    
    return MultiProvider(
      providers: [
        // Provide global services
        ChangeNotifierProvider<FirebaseAuthService>.value(
          value: ServiceInitializer.get<FirebaseAuthService>(),
        ),
        Provider<DocumentStorageService>(
          create: (_) => ServiceInitializer.get<DocumentStorageService>(),
        ),

        // Provide localization service with change notifier
        ChangeNotifierProvider<LocalizationService>.value(
          value: localizationService,
        ),
        // Provide accessibility service
        ChangeNotifierProvider<AccessibilityService>.value(
          value: accessibilityService,
        ),
      ],
      child: Consumer<AccessibilityService>(
        builder: (context, accessibilityService, _) {
          
          // Get base theme
          final baseTheme = ThemeData(
            colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
            useMaterial3: true,
          );
          
          // Apply accessibility settings to theme
          final theme = accessibilityService.getThemeData(baseTheme);
          
          return Consumer<LocalizationService>(
            builder: (context, localizationService, _) {
              // Key ensures full app rebuild when localization changes
              return MaterialApp(
                key: ValueKey(localizationService.currentLocale.toString()),
                navigatorKey: InAppMessagingService.navigatorKey,
                title: 'Flight Compensation Assistant',
                theme: theme,
                // Add localization support
                locale: localizationService.currentLocale,
                localizationsDelegates: const [
                  AppLocalizations.delegate,
                  GlobalMaterialLocalizations.delegate,
                  GlobalWidgetsLocalizations.delegate,
                  GlobalCupertinoLocalizations.delegate,
                ],
                supportedLocales: LocalizationService.supportedLocales,
                // Support system text scaling preferences
                builder: (context, child) {
                  if (child == null) return Container();
                  
                  // Apply text scaling safely based on accessibility settings
                  final MediaQueryData mediaQueryData = MediaQuery.of(context);
                  final double textScaleFactor = accessibilityService.getTextScaleFactor();
                  
                  // Use the fixed textScaler to avoid assertion errors
                  return MediaQuery(
                    data: mediaQueryData.copyWith(
                      // Use LinearTextScaler instead of directly specifying textScaler
                      // This avoids assertion errors with fontSize
                      textScaler: TextScaler.linear(textScaleFactor),
                    ),
                    child: Stack(
                      children: [
                        child,
                        // Web-only consent banner lives above the UI
                        const ConsentBanner(),
                      ],
                    ),
                  );
                },
                home: const AuthGate(),
                routes: {
                  // The '/' route is now handled by the AuthGate
                  // It is no longer needed here

                  // New improved auth screen
                  '/auth': (context) => const AuthScreen(),
                  // Backward-compatible route now points to the unified AuthScreen
                  '/email-auth': (context) => const AuthScreen(),
                  '/edit-profile': (context) => const ProfileEditScreen(),
                  '/compensation-checker': (context) => const FlightCompensationCheckerScreen(),
                  '/accessibility-settings': (context) => const AccessibilitySettingsScreen(),
                  '/language-selection': (context) => const LanguageSelectionScreen(),
                  '/claim-submission': (context) => const ClaimSubmissionScreen(),
                  '/push-notification-test': (context) => const PushNotificationTestScreen(),
                  '/donation': (context) {
                    if (!ServiceInitializer.donationsEnabled) {
                      return const Scaffold(
                        body: Center(
                          child: Padding(
                            padding: EdgeInsets.all(24),
                            child: Text('Donations are temporarily disabled.'),
                          ),
                        ),
                      );
                    }
                    return const DonationScreen();
                  },
                  '/community-impact': (context) => const CommunityImpactScreen(),
                  // Legal & compliance routes (web/mobile)
                  '/privacy': (context) => const PrivacyPolicyScreen(),
                  '/terms': (context) => const TermsOfServiceScreen(),
                  '/cookies': (context) => const CookiePolicyScreen(),
                  '/legal': (context) => const LegalNoticeScreen(),
                  '/accessibility': (context) => const AccessibilityStatementScreen(),
                  // Debug/testing route for attachment screen (accepts arguments: { claim, userEmail })
                  '/claim-attachments': (context) {
                    final args = ModalRoute.of(context)?.settings.arguments as Map<String, dynamic>?;
                    if (args == null || args['claim'] == null) {
                      return const Scaffold(
                        body: Center(child: Text('Missing claim argument for ClaimAttachmentScreen')),
                      );
                    }
                    return ClaimAttachmentScreen(
                      claim: args['claim'],
                      userEmail: args['userEmail'] as String?,
                    );
                  },
                },
              );
            },
          );
        },
      ),
    );
  }
}

class AuthGate extends StatelessWidget {
  const AuthGate({super.key});

  @override
  Widget build(BuildContext context) {
    final authService = context.watch<FirebaseAuthService>();

    // DEBUG: Track what user is being used for routing decision
    print('üî¥üî¥üî¥ AUTHGATE: Checking currentUser for routing...');
    print('üî¥ AuthGate: currentUser = ${authService.currentUser}');
    print('üî¥ AuthGate: currentUser != null = ${authService.currentUser != null}');
    if (authService.currentUser != null) {
      print('üî¥ AuthGate: User exists - showing MainNavigation');
      print('üî¥ AuthGate: User details: ${authService.currentUser!.displayName} (${authService.currentUser!.email})');
    } else {
      print('üî¥ AuthGate: No user - showing AuthScreen');
    }

    // The authService now uses ChangeNotifier. We watch it for changes
    // and rebuild the UI accordingly.
    if (authService.currentUser != null) {
      return const MainNavigation();
    } else {
      return const AuthScreen();
    }
  }
}